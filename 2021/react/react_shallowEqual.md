### shallowEqual

```
	// 用原型链的方法
	const hasOwn = Object.prototype.hasOwnProperty

	// 这个函数实际上是Object.is()的polyfill
	function is(x, y) {
	  if (x === y) {
	    return x !== 0 || y !== 0 || 1 / x === 1 / y
	  } else {
	    return x !== x && y !== y
	  }
	}

	export default function shallowEqual(objA, objB) {
	  // 首先对基本数据类型的比较
	  if (is(objA, objB)) return true
	  // 由于Obejct.is()可以对基本数据类型做一个精确的比较， 所以如果不等
	  // 只有一种情况是误判的，那就是object,所以在判断两个对象都不是object
	  // 之后，就可以返回false了
	  if (typeof objA !== 'object' || objA === null ||
	      typeof objB !== 'object' || objB === null) {
	    return false
	  }

	  // 过滤掉基本数据类型之后，就是对对象的比较了
	  // 首先拿出key值，对key的长度进行对比

	  const keysA = Object.keys(objA)
	  const keysB = Object.keys(objB)

	  // 长度不等直接返回false
	  if (keysA.length !== keysB.length) return false
	  // key相等的情况下，在去循环比较
	  for (let i = 0; i < keysA.length; i++) {
	  // key值相等的时候
	  // 借用原型链上真正的 hasOwnProperty 方法，判断ObjB里面是否有A的key的key值
	  // 属性的顺序不影响结果也就是{name:'daisy', age:'24'} 跟{age:'24'，name:'daisy' }是一样的
	  // 最后，对对象的value进行一个基本数据类型的比较，返回结果
	    if (!hasOwn.call(objB, keysA[i]) ||
	        !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false
	    }
	  }

	  return true
	}
```
对比的类型为Object的时候并且key的长度相等的时候，浅比较也仅仅是用Object.is()对Object的value做了一个基本数据类型的比较，所以如果key里面是对象的话，有可能出现比较不符合预期的情况，所以浅比较是不适用于嵌套类型的比较的。

